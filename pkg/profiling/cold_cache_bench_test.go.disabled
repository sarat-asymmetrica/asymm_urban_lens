// Package profiling - Cold-Cache Benchmarks for Production Performance
//
// MISSION: Carmack says "That's synthetic benchmarks with cache-hot data."
//
// This file provides REALISTIC performance numbers by:
// 1. Flushing CPU cache before each run
// 2. Using production-sized datasets
// 3. Mixing operations like real workloads
// 4. Simulating I/O delays
//
// Philosophy: Real-world performance > synthetic benchmarks
// Expectation: Cold cache 2-10× slower than warm cache
//
// MATHEMATICAL FOUNDATION:
//   Cache-Hot:  Data in L1/L2 (1-10 cycles)
//   Cache-Cold: Data in RAM (100-300 cycles)
//   Ratio:      10× - 300× latency difference
//
// Author: Claude Opus 4.5 (Zen Gardener)
// Date: December 27, 2025
// Context: asymm_urbanlens production optimization
package profiling

import (
	"context"
	"math/rand"
	"runtime"
	"testing"
	"time"

	"github.com/asymmetrica/urbanlens/pkg/vqc"
)

// ═══════════════════════════════════════════════════════════════════════════
// CACHE CONTROL - Force Cache Misses
// ═══════════════════════════════════════════════════════════════════════════

const (
	// Cache sizes (Intel/AMD typical)
	L1CacheSize = 32 * 1024       // 32 KB L1 per core
	L2CacheSize = 256 * 1024      // 256 KB L2 per core
	L3CacheSize = 8 * 1024 * 1024 // 8 MB L3 shared
)

// ClearCPUCache flushes CPU caches by traversing large memory region
//
// Strategy: Access memory larger than L3 cache in random pattern
// This forces cache eviction due to capacity misses
//
// Formula: Access 16 MB (2× L3 cache size) to ensure complete flush
func ClearCPUCache() {
	// Allocate 16 MB array (2× typical L3 cache)
	const flushSize = 16 * 1024 * 1024 / 8 // 2M float64s
	data := make([]float64, flushSize)

	// Fill with random values
	for i := range data {
		data[i] = rand.Float64()
	}

	// Random access pattern (defeats prefetcher!)
	sum := 0.0
	for i := 0; i < flushSize; i++ {
		// Random index (prevents sequential prefetch)
		idx := (i * 7919) % flushSize // 7919 is prime
		sum += data[idx]
	}

	// Prevent compiler optimization
	if sum > 1e100 {
		println("Cache flush complete")
	}

	// Force garbage collection to clear any cached allocations
	runtime.GC()
}

// WarmupCache ensures data is in cache before warm benchmark
func WarmupCache(data interface{}) {
	// Access the data multiple times to load into cache
	switch v := data.(type) {
	case []int:
		sum := 0
		for _, val := range v {
			sum += val
		}
		if sum > 1e20 {
			println("Warmup complete")
		}
	case []vqc.Quaternion:
		sum := float64(0)
		for i := 0; i < len(v); i++ {
			sum += float64(v[i].W + v[i].X + v[i].Y + v[i].Z)
		}
		if sum > 1e20 {
			println("Warmup complete")
		}
	}
}

// ═══════════════════════════════════════════════════════════════════════════
// VQC BENCHMARKS - Warm vs Cold Cache
// ═══════════════════════════════════════════════════════════════════════════

// BenchmarkWarmVQC_DigitalRoot - Baseline with warm cache
func BenchmarkWarmVQC_DigitalRoot(b *testing.B) {
	candidates := make([]int, 10000)
	for i := 0; i < 10000; i++ {
		candidates[i] = i
	}

	// Warmup: Load data into cache
	WarmupCache(candidates)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = vqc.DigitalRootFilter(candidates, 1000)
	}
}

// BenchmarkColdVQC_DigitalRoot - Reality check with cold cache
func BenchmarkColdVQC_DigitalRoot(b *testing.B) {
	candidates := make([]int, 10000)
	for i := 0; i < 10000; i++ {
		candidates[i] = i
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Clear cache before EACH iteration
		ClearCPUCache()

		_ = vqc.DigitalRootFilter(candidates, 1000)
	}
}

// BenchmarkWarmVQC_WilliamsOptimizer - Baseline batch optimization
func BenchmarkWarmVQC_WilliamsOptimizer(b *testing.B) {
	items := make([]interface{}, 10000)
	for i := 0; i < 10000; i++ {
		items[i] = i
	}

	optimizer := vqc.NewWilliamsOptimizer()
	WarmupCache(items)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = optimizer.OptimizeBatch(items, func(batch []interface{}) error {
			// Simulate processing
			sum := 0
			for _, item := range batch {
				sum += item.(int)
			}
			return nil
		})
	}
}

// BenchmarkColdVQC_WilliamsOptimizer - Reality with cold cache
func BenchmarkColdVQC_WilliamsOptimizer(b *testing.B) {
	items := make([]interface{}, 10000)
	for i := 0; i < 10000; i++ {
		items[i] = i
	}

	optimizer := vqc.NewWilliamsOptimizer()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ClearCPUCache()

		_ = optimizer.OptimizeBatch(items, func(batch []interface{}) error {
			sum := 0
			for _, item := range batch {
				sum += item.(int)
			}
			return nil
		})
	}
}

// BenchmarkWarmVQC_SLERP - Geodesic interpolation (warm)
func BenchmarkWarmVQC_SLERP(b *testing.B) {
	q0 := vqc.NewQuaternion(1, 0, 0, 0)
	q1 := vqc.NewQuaternion(0, 1, 0, 0)

	// Warmup
	for i := 0; i < 100; i++ {
		_ = vqc.SLERP(q0, q1, 0.5)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = vqc.SLERP(q0, q1, 0.5)
	}
}

// BenchmarkColdVQC_SLERP - Reality check
func BenchmarkColdVQC_SLERP(b *testing.B) {
	q0 := vqc.NewQuaternion(1, 0, 0, 0)
	q1 := vqc.NewQuaternion(0, 1, 0, 0)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if i%100 == 0 {
			ClearCPUCache()
		}
		_ = vqc.SLERP(q0, q1, 0.5)
	}
}

// BenchmarkWarmVQC_QuaternionArray - Batch operations (warm)
func BenchmarkWarmVQC_QuaternionArray(b *testing.B) {
	const size = 1000
	quaternions := make([]vqc.Quaternion, size)
	for i := 0; i < size; i++ {
		quaternions[i] = vqc.RandomQuaternion()
	}

	WarmupCache(quaternions)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sum := float64(0)
		for j := 0; j < size; j++ {
			sum += float64(quaternions[j].Norm())
		}
		if sum > 1e20 {
			println("Done")
		}
	}
}

// BenchmarkColdVQC_QuaternionArray - Reality check
func BenchmarkColdVQC_QuaternionArray(b *testing.B) {
	const size = 1000
	quaternions := make([]vqc.Quaternion, size)
	for i := 0; i < size; i++ {
		quaternions[i] = vqc.RandomQuaternion()
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ClearCPUCache()

		sum := float64(0)
		for j := 0; j < size; j++ {
			sum += float64(quaternions[j].Norm())
		}
		if sum > 1e20 {
			println("Done")
		}
	}
}

// ═══════════════════════════════════════════════════════════════════════════
// MIXED WORKLOAD BENCHMARKS - Production Simulation
// ═══════════════════════════════════════════════════════════════════════════

// BenchmarkMixedWorkload_Warm - Simulates typical production mix (warm)
//
// Mix: 50% VQC computations, 30% digital root, 20% optimization
func BenchmarkMixedWorkload_Warm(b *testing.B) {
	// Setup data
	quaternions := make([]vqc.Quaternion, 100)
	for i := 0; i < 100; i++ {
		quaternions[i] = vqc.RandomQuaternion()
	}

	candidates := make([]int, 1000)
	for i := 0; i < 1000; i++ {
		candidates[i] = i
	}

	// Warmup
	WarmupCache(quaternions)
	WarmupCache(candidates)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// 50% VQC quaternion operations
		for j := 0; j < 50; j++ {
			idx1 := j % 100
			idx2 := (j + 1) % 100
			_ = quaternions[idx1].Multiply(quaternions[idx2])
		}

		// 30% digital root filtering
		for j := 0; j < 30; j++ {
			_ = vqc.DigitalRoot(candidates[j])
		}

		// 20% optimization analysis
		for j := 0; j < 20; j++ {
			_ = vqc.OptimalBatchSize(candidates[j])
		}
	}
}

// BenchmarkMixedWorkload_Cold - Production reality check
func BenchmarkMixedWorkload_Cold(b *testing.B) {
	quaternions := make([]vqc.Quaternion, 100)
	for i := 0; i < 100; i++ {
		quaternions[i] = vqc.RandomQuaternion()
	}

	candidates := make([]int, 1000)
	for i := 0; i < 1000; i++ {
		candidates[i] = i
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Clear cache every iteration
		ClearCPUCache()

		// 50% VQC quaternion operations
		for j := 0; j < 50; j++ {
			idx1 := j % 100
			idx2 := (j + 1) % 100
			_ = quaternions[idx1].Multiply(quaternions[idx2])
		}

		// 30% digital root filtering
		for j := 0; j < 30; j++ {
			_ = vqc.DigitalRoot(candidates[j])
		}

		// 20% optimization analysis
		for j := 0; j < 20; j++ {
			_ = vqc.OptimalBatchSize(candidates[j])
		}
	}
}

// ═══════════════════════════════════════════════════════════════════════════
// PRODUCTION SIMULATION - I/O + Computation
// ═══════════════════════════════════════════════════════════════════════════

// BenchmarkProductionSimulation - Real-world workload with I/O
//
// Simulates:
// - File I/O delays (1-5ms typical for SSD)
// - Memory allocation churn
// - Mixed computation patterns
// - Context switching
func BenchmarkProductionSimulation(b *testing.B) {
	ctx := context.Background()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// 1. Simulate file read (SSD latency: 1-5ms)
		time.Sleep(2 * time.Millisecond)

		// 2. Parse "data" into quaternions
		data := make([]vqc.Quaternion, 50)
		for j := 0; j < 50; j++ {
			data[j] = vqc.NewQuaternion(
				float64(rand.Float64()),
				float64(rand.Float64()),
				float64(rand.Float64()),
				float64(rand.Float64()),
			).Normalize()
		}

		// 3. Process with VQC optimization
		optimizer := vqc.NewWilliamsOptimizer()
		batchSize := vqc.OptimalBatchSize(len(data))

		items := make([]interface{}, len(data))
		for j := range data {
			items[j] = data[j]
		}

		_ = optimizer.OptimizeBatch(items, func(batch []interface{}) error {
			// Simulate processing each quaternion
			for _, item := range batch {
				q := item.(vqc.Quaternion)
				_ = q.Multiply(q)
			}
			return nil
		})

		// 4. Simulate database write (5-10ms typical)
		time.Sleep(5 * time.Millisecond)

		// 5. Check context (production code does this!)
		select {
		case <-ctx.Done():
			return
		default:
		}

		// 6. Clear some cache (simulates other processes)
		if i%10 == 0 {
			runtime.GC()
		}
	}

	// Report effective throughput
	b.ReportMetric(float64(b.N)/b.Elapsed().Seconds(), "ops/sec")
}

// ═══════════════════════════════════════════════════════════════════════════
// STREAMING BENCHMARKS - Real Data Flow Patterns
// ═══════════════════════════════════════════════════════════════════════════

// BenchmarkStreamingProcessing_Warm - Channel-based pipeline (warm)
func BenchmarkStreamingProcessing_Warm(b *testing.B) {
	const batchSize = 100

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Create channels
		input := make(chan vqc.Quaternion, batchSize)
		output := make(chan float64, batchSize)

		// Producer
		go func() {
			for j := 0; j < batchSize; j++ {
				input <- vqc.RandomQuaternion()
			}
			close(input)
		}()

		// Consumer
		go func() {
			for q := range input {
				output <- float64(q.Norm())
			}
			close(output)
		}()

		// Collect results
		sum := float64(0)
		for norm := range output {
			sum += norm
		}
	}
}

// BenchmarkStreamingProcessing_Cold - Reality with cache pressure
func BenchmarkStreamingProcessing_Cold(b *testing.B) {
	const batchSize = 100

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ClearCPUCache()

		input := make(chan vqc.Quaternion, batchSize)
		output := make(chan float64, batchSize)

		go func() {
			for j := 0; j < batchSize; j++ {
				input <- vqc.RandomQuaternion()
			}
			close(input)
		}()

		go func() {
			for q := range input {
				output <- float64(q.Norm())
			}
			close(output)
		}()

		sum := float64(0)
		for norm := range output {
			sum += norm
		}
	}
}

// ═══════════════════════════════════════════════════════════════════════════
// MEMORY ALLOCATION BENCHMARKS - GC Pressure
// ═══════════════════════════════════════════════════════════════════════════

// BenchmarkAllocation_Warm - Memory churn (warm)
func BenchmarkAllocation_Warm(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Allocate quaternion arrays (typical production pattern)
		batch := make([]vqc.Quaternion, 100)
		for j := 0; j < 100; j++ {
			batch[j] = vqc.RandomQuaternion()
		}

		// Process (prevents dead code elimination)
		sum := float64(0)
		for _, q := range batch {
			sum += float64(q.Norm())
		}

		if sum > 1e20 {
			println("Done")
		}
	}
}

// BenchmarkAllocation_Cold - Reality with GC pressure
func BenchmarkAllocation_Cold(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Force GC every 10 iterations (simulates production load)
		if i%10 == 0 {
			runtime.GC()
			ClearCPUCache()
		}

		batch := make([]vqc.Quaternion, 100)
		for j := 0; j < 100; j++ {
			batch[j] = vqc.RandomQuaternion()
		}

		sum := float64(0)
		for _, q := range batch {
			sum += float64(q.Norm())
		}

		if sum > 1e20 {
			println("Done")
		}
	}
}

// BenchmarkThreeRegimeEvolution_Warm - Three-regime workflow (warm)
func BenchmarkThreeRegimeEvolution_Warm(b *testing.B) {
	regime := vqc.NewTargetRegime()

	// Warmup
	for i := 0; i < 10; i++ {
		regime.ApplyDamping()
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		regime = regime.ApplyDamping()
		_ = regime.ConvergenceScore()
	}
}

// BenchmarkThreeRegimeEvolution_Cold - Reality check
func BenchmarkThreeRegimeEvolution_Cold(b *testing.B) {
	regime := vqc.NewTargetRegime()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if i%100 == 0 {
			ClearCPUCache()
		}
		regime = regime.ApplyDamping()
		_ = regime.ConvergenceScore()
	}
}

// ═══════════════════════════════════════════════════════════════════════════
// ANALYSIS HELPERS
// ═══════════════════════════════════════════════════════════════════════════

// CompareWarmCold runs warm/cold benchmarks and reports ratio
//
// Usage:
//   go test -bench=BenchmarkWarmVQC_DigitalRoot -benchmem
//   go test -bench=BenchmarkColdVQC_DigitalRoot -benchmem
//
// Expected: Cold 2-10× slower than warm
//
// Example output:
//   BenchmarkWarmVQC-8   1000000   1500 ns/op   0 B/op   0 allocs/op
//   BenchmarkColdVQC-8    100000  15000 ns/op   0 B/op   0 allocs/op
//   Ratio: 10× (cache-cold penalty)
